<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>软件工程 on Syek.com</title><link>https://eSparkL.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</link><description>Recent content in 软件工程 on Syek.com</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Sun, 11 May 2025 19:24:08 +0800</lastBuildDate><atom:link href="https://eSparkL.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/rss.xml" rel="self" type="application/rss+xml"/><item><title>软件工程思路笔记</title><link>https://eSparkL.github.io/study/4-%E8%BD%AF%E5%B7%A5%E8%AF%BE%E5%A0%82%E6%80%9D%E8%B7%AF%E7%AC%94%E8%AE%B0/</link><pubDate>Sun, 11 May 2025 19:24:08 +0800</pubDate><guid>https://eSparkL.github.io/study/4-%E8%BD%AF%E5%B7%A5%E8%AF%BE%E5%A0%82%E6%80%9D%E8%B7%AF%E7%AC%94%E8%AE%B0/</guid><description>&lt;p>tags:
[TOC]&lt;/p>
&lt;h2 id="需求工程">需求工程
&lt;a class="header-anchor" href="#%e9%9c%80%e6%b1%82%e5%b7%a5%e7%a8%8b">&lt;/a>
&lt;/h2>&lt;h3 id="用例规约">用例规约
&lt;a class="header-anchor" href="#%e7%94%a8%e4%be%8b%e8%a7%84%e7%ba%a6">&lt;/a>
&lt;/h3>&lt;h4 id="1-画出use-case">1. 画出Use Case
&lt;a class="header-anchor" href="#1-%e7%94%bb%e5%87%bause-case">&lt;/a>
&lt;/h4>&lt;h4 id="2-编写用例规约">2. 编写用例规约
&lt;a class="header-anchor" href="#2-%e7%bc%96%e5%86%99%e7%94%a8%e4%be%8b%e8%a7%84%e7%ba%a6">&lt;/a>
&lt;/h4>&lt;h5 id="1-可选需求">1. 可选需求
&lt;a class="header-anchor" href="#1-%e5%8f%af%e9%80%89%e9%9c%80%e6%b1%82">&lt;/a>
&lt;/h5>&lt;h5 id="2-非功能需求">2. 非功能需求
&lt;a class="header-anchor" href="#2-%e9%9d%9e%e5%8a%9f%e8%83%bd%e9%9c%80%e6%b1%82">&lt;/a>
&lt;/h5>&lt;h5 id="3-黑盒用例规约-和-白盒用例规约">3. 黑盒用例规约 和 白盒用例规约
&lt;a class="header-anchor" href="#3-%e9%bb%91%e7%9b%92%e7%94%a8%e4%be%8b%e8%a7%84%e7%ba%a6-%e5%92%8c-%e7%99%bd%e7%9b%92%e7%94%a8%e4%be%8b%e8%a7%84%e7%ba%a6">&lt;/a>
&lt;/h5>&lt;ul>
&lt;li>随着开发的过程要不断添加细节
&lt;ul>
&lt;li>1.识别用例：有哪些时间、actor&lt;/li>
&lt;li>2.用例分布提纲：+前置条件 +后置条件&lt;/li>
&lt;li>3.（非技术甲方）黑盒规约：+完整的事件流&lt;/li>
&lt;li>4.（技术人员）白盒规约：+系统内部行为的细节描述&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>可以采用双列（用户视图 | 系统视图）&lt;/li>
&lt;/ul>
&lt;h4 id="3-用例图优化">3. 用例图优化
&lt;a class="header-anchor" href="#3-%e7%94%a8%e4%be%8b%e5%9b%be%e4%bc%98%e5%8c%96">&lt;/a>
&lt;/h4>&lt;ul>
&lt;li>符号：
&lt;ul>
&lt;li>Include包含&lt;img src="https://eSparkL.github.io/imgs/img-lazy-loading.gif" data-src="image-2.png" alt="alt text" />
&lt;ul>
&lt;li>从基本用例→包含用例，包含用例为基本用例提供功能&lt;/li>
&lt;li>&amp;lt;&amp;gt;衍型&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Extend扩展&lt;img src="https://eSparkL.github.io/imgs/img-lazy-loading.gif" data-src="image-1.png" alt="alt text" />&lt;/li>
&lt;li>Generalization泛化（类似类中的继承关系）&lt;img src="https://eSparkL.github.io/imgs/img-lazy-loading.gif" data-src="image.png" alt="alt text" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Include关系
&lt;ul>
&lt;li>基数&lt;/li>
&lt;li>Include中，不需要处理条件，&lt;/li>
&lt;li>分离非主要行为，突出用例的核心价值&lt;/li>
&lt;li>提出多个用例存在一段共有的行为，可以提取出来反复使用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Extend关系（见图）
&lt;ul>
&lt;li>Extension扩展用例——Base基本用例&lt;/li>
&lt;li>基数&lt;/li>
&lt;li>扩展关系符号是&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Generalization泛化，&lt;/li>
&lt;/ul>
&lt;h4 id="建立概念模型conceptual-class">建立概念模型Conceptual Class
&lt;a class="header-anchor" href="#%e5%bb%ba%e7%ab%8b%e6%a6%82%e5%bf%b5%e6%a8%a1%e5%9e%8bconceptual-class">&lt;/a>
&lt;/h4>&lt;h5 id="识别conceptual-class">识别Conceptual Class
&lt;a class="header-anchor" href="#%e8%af%86%e5%88%abconceptual-class">&lt;/a>
&lt;/h5>&lt;ul>
&lt;li>分类法
&lt;ul>
&lt;li>物理实体&lt;/li>
&lt;li>逻辑实体&lt;/li>
&lt;li>组织实体&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>名词提取法
&lt;ul>
&lt;li>1.从规约中提取所有名词，可重复&lt;/li>
&lt;li>2.去掉：冗余、执行者和系统本身、边界类（菜单、链接）、类的属性&lt;/li>
&lt;li>3.得到基本概念类&lt;/li>
&lt;li>易错：类的实体当做属性被删掉（e.g.型号）
&lt;ul>
&lt;li>属性特征：数字，文本&lt;/li>
&lt;li>因此如果一个东西不能简单用数字或文本描述，应该为类而非属性&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h5 id="建立conceptual-class之间的关系">建立Conceptual Class之间的关系
&lt;a class="header-anchor" href="#%e5%bb%ba%e7%ab%8bconceptual-class%e4%b9%8b%e9%97%b4%e7%9a%84%e5%85%b3%e7%b3%bb">&lt;/a>
&lt;/h5>&lt;ul>
&lt;li>类图：类 + 类之间的关系&lt;/li>
&lt;li>类是结构，结构是&lt;strong>静态&lt;/strong>的&lt;/li>
&lt;li>UML&lt;img src="https://eSparkL.github.io/imgs/img-lazy-loading.gif" data-src="image-5.png" alt="alt text" />
&lt;ul>
&lt;li>类名 | 属性 | 操作&lt;/li>
&lt;li>可见性Visibility
&lt;ul>
&lt;li>+公共可见性&lt;/li>
&lt;li>#受保护&lt;/li>
&lt;li>-私有&lt;/li>
&lt;li>~包可见&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>多重性Multiplicity
&lt;ul>
&lt;li>描述关联
&lt;ul>
&lt;li>*无限多个&lt;/li>
&lt;li>1， 2， 0， 正好1，2，0个&lt;/li>
&lt;li>{1 or 2&amp;hellip;4}离散值&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>vs
&lt;ul>
&lt;li>基数：整个关系&lt;/li>
&lt;li>多重性：某一端，“从这边看过去，能连几个那边”&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>关联关系Relationship：Association
&lt;ul>
&lt;li>“一个类知道另一个类”
&lt;ul>
&lt;li>无箭头实线：彼此都知道
&lt;ul>
&lt;li>↑耦合性&lt;/li>
&lt;li>但更灵活&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>单向实线：A知道B，A→B，订单→支付方式
&lt;ul>
&lt;li>符合封装原则，↓耦合&lt;/li>
&lt;li>但导航性可能会比较麻烦，比如反向查询不方便
&lt;ul>
&lt;li>导航性：一个类能否通过关联访问另一个类
&lt;ul>
&lt;li>决定哪个类负责持有或访问数据&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>需求分析阶段&lt;/li>
&lt;li>设计阶段&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>聚合关系Relationship：Aggregation
&lt;ul>
&lt;li>整体-部分&lt;/li>
&lt;li>空菱形实线箭头，菱形在整体&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>组合关系Relationship：Composition
&lt;ul>
&lt;li>生命周期，部分和组合一起消亡，强关联&lt;/li>
&lt;li>实菱形实线箭头&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>泛化关系Relationship：Generalization
&lt;ul>
&lt;li>空心实线箭头，空心箭头在父类&lt;/li>
&lt;li>尽量避免用多重继承
&lt;ul>
&lt;li>重复继承问题，&lt;code>“钻石问题”&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>优化：
&lt;ul>
&lt;li>Liskov替换准则LSP&lt;/li>
&lt;li>继承是is a kind of关系，即子类应该能替换基类型&lt;img src="https://eSparkL.github.io/imgs/img-lazy-loading.gif" data-src="image-3.png" alt="alt text" />&lt;/li>
&lt;li>区分：泛化 vs 聚合
&lt;ul>
&lt;li>带滚动条的窗口
&lt;ul>
&lt;li>带滚动条的窗口 是 窗口；带滚动条的窗口 包含了 滚动条&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>依赖关系Relationship：Dependency
&lt;ul>
&lt;li>虚线带箭头，依赖类型&amp;laquo;自定义&amp;raquo;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>接口
&lt;ul>
&lt;li>一组操作的集合（不包含属性）&lt;/li>
&lt;li>表示方法&lt;img src="https://eSparkL.github.io/imgs/img-lazy-loading.gif" data-src="image-6.png" alt="alt text" />
&lt;ul>
&lt;li>&amp;lt;&amp;gt;&lt;/li>
&lt;li>圆圈表示&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>分类
&lt;ul>
&lt;li>供给接口
&lt;ul>
&lt;li>提供的服务&lt;/li>
&lt;li>圆圈&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>需求接口
&lt;ul>
&lt;li>需要得到的服务&lt;/li>
&lt;li>半圆&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>增加属性，类的属性（先）比操作（后）更重要&lt;/li>
&lt;li>状态机图
&lt;ul>
&lt;li>类的行为性特征&lt;/li>
&lt;li>分类
&lt;ul>
&lt;li>行为状态机
&lt;ul>
&lt;li>内部&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>协议状态机
&lt;ul>
&lt;li>外部&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>核心元素
&lt;ul>
&lt;li>初始状态：实心圆⚫&lt;/li>
&lt;li>终止状态：圆圈包围⚫&lt;/li>
&lt;li>其他状态：圆角矩形，内部显示状态名&lt;/li>
&lt;li>状态转移：
&lt;ul>
&lt;li>箭头&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>事件：状态机中事件触发迁移
&lt;ul>
&lt;li>转移上的标号表示&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>entry-do-exit-event？&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>为什么要用状态机图
&lt;ul>
&lt;li>1.对象的职责或行为变化显著&lt;/li>
&lt;li>2.系统或对象的用例涉及复杂的逻辑，且这些逻辑由状态驱动时&lt;/li>
&lt;li>×：
&lt;ul>
&lt;li>对象的逻辑简单明了，不需要额外的状态机抽象&lt;/li>
&lt;li>对象的行为不依赖状态变化&lt;/li>
&lt;li>对象单一状态&lt;/li>
&lt;li>总结：不存在复杂的状态变化&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="用例实现ucr">用例实现UCR
&lt;a class="header-anchor" href="#%e7%94%a8%e4%be%8b%e5%ae%9e%e7%8e%b0ucr">&lt;/a>
&lt;/h4>&lt;h4 id="">
&lt;a class="header-anchor" href="#">&lt;/a>
&lt;/h4>&lt;ul>
&lt;li>需求和设计之间的桥梁&lt;/li>
&lt;li>用例中的每一个用力，在分析模型和设计模型中至少有一个用例实现与对应&lt;/li>
&lt;li>分类
&lt;ul>
&lt;li>动态交互图&lt;/li>
&lt;li>类图，静态视图&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h5 id="识别分析类">识别分析类
&lt;a class="header-anchor" href="#%e8%af%86%e5%88%ab%e5%88%86%e6%9e%90%e7%b1%bb">&lt;/a>
&lt;/h5>&lt;ul>
&lt;li>分析类：描述每个角色的职责&lt;/li>
&lt;li>设计阶段：角色赋与台词和动作，变成实际的系统组件&lt;/li>
&lt;li>分析类：
&lt;ul>
&lt;li>平台无关模型，与实现无关（可能做不出来）&lt;/li>
&lt;li>MVC模型-视图-控制器
&lt;ul>
&lt;li>实体类
&lt;ul>
&lt;li>描述存储的信息，及信息相关的行为&lt;/li>
&lt;li>反映逻辑数据结构&lt;/li>
&lt;li>实体类不是某个用力实现所特有的&lt;/li>
&lt;li>识别：名词过滤&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>边界类
&lt;ul>
&lt;li>分类
&lt;ul>
&lt;li>用户界面类&lt;/li>
&lt;li>系统接口类&lt;/li>
&lt;li>设备接口类&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>识别规则actor和用例之间的一条通信关联对应一个边界类，actor是什么类型对应对应的边界类&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>控制类
&lt;ul>
&lt;li>每一个用例一定会有一个控制类&lt;/li>
&lt;li>关注流程逻辑，是事件流的抽象&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="构建分析模型">构建分析模型
&lt;a class="header-anchor" href="#%e6%9e%84%e5%bb%ba%e5%88%86%e6%9e%90%e6%a8%a1%e5%9e%8b">&lt;/a>
&lt;/h4>&lt;ul>
&lt;li>交互图
&lt;ul>
&lt;li>
&lt;p>顺序图/时序图&lt;/p></description></item></channel></rss>